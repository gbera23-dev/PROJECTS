Once the variable is declared in the stack, it 
could be referenced at some point in the scope, so we need separate structure where we will store information
(information will be a variable type and name of the variable, both char*, so 8 bytes). There is currently no
other reason to maintain the information of anything else. All the data we have in the C program is in the
declared variable. We will just create a kind of a data structure, that will maintain declared variable names
and types. And allow us to store, find, retrieve and delete information fast enough. For this, I will use my 
own generic structure I wrote in one of the assignments of the paradigms. I do not, at first, care about 
efficiency, so I will use my vector. I htink there is no need to create separate module for this, Mr_Assembler will take care of it! 
However, it has to be noted that Data.c will not use our vector, because it is a static memory, its size never changes, 
it will be a block of memory allocated on the heap and cleaned
after program ends, I will declare constant variables for number of tokens and create a array of char*'s, which
will be stored in the heap. This is the first thing I will start writing. I will just have a struct which defines
a type, that is the name of the type with the int(amount of bytes needed to declare this type). and that struct
will be stored in my static array. The whole purpose of Data.c and Data.h files will be to have a "static" 
function that will generate this static array in heap and return the pointer to it. So I need Type struct and
definition of init function in the Data.h. Data.c will be implemented now. 

We add additional c files that have _test after name and before .c. They will be used for testing purposes, BUT
will be removed when project is ready. test files will allow us to be confident that implementations of our
functions are valid and sound. 

Now, we shall start making the Mr_Assembler's life harder. We need to think about what attributes
does Mr_Assembler need to maintain. Since initially all we have are variable declarations and
operations. We need to store variable names and also store pointer to a Data to understand 
whether we have new variable declaration or do we have operation on already existing variable. 

Mr_Assember will use instructions module, to generate elementary instructions for tokens.
We currently have support for variables of size 4 and 1(float cannot be loaded in the register
and this has to be figured out how to do it properly) and we have simple type declaration of 
the variable(e.g int x;), assignment of the variable (e.g y = 3; or int z = 5;), and printing
of the variable(custom function different from C's printf(will probably add printf later)). 
This all has to be implemented(we have to implement Mr_Assembler's functions). Then, for the
future, we will figure out how to use operators like(+, *, (, ), /) on variables and blend them
with already defined instructions. 

Before we delve in implementing Mr_Assembler. We need one more module and one extra function in CRC.c. 

We need stringTokenizer module(and I will implement it) and also CRC.c must be able to trim each command, before passing
all the commands to hands of Mr_Assembler. 

I just found strtok function of c and it is very very good in doing what I want, it removes all the problems, but cleaning
strings before passing them to strtok is still hygienic and necessary. I will heavily depend on this function during 
implementation of Mr_Assembler, which I will soon start. 

I have done two things: 

I have cleaned each token fully and discover strtok that will be used to further tokenize each token. Now, I will create new
strVector in main and pass it to Mr_Assembler, then implement the main and initial functionality of Mr_Assember.

We are getting close...

As it seems, we need more functionality than we currently have targeted. 

We need to have functions, their pointers, all pointer support, user can create structs.

These are full requirements that my program must follow, and it needs careful thought: 
ის უნდა მუშაობდეს შემდეგ ტიპებთან:
Პრიმიტიული ტიპები
char - 1 ბაიტი ok
short - 2 ბაიტი ok
int - 4 ბაიტი ok 
long - 8 ბაიტი ? needs analysis
Მიმთითებლები (void*, int*, …) ok its possible
ფუნქციები და მათზე მიმთითებლები I will add functions and about function pointers, will think about it  
Სტრუქტურები რომლებიც შეიძლება მოიცავდნენ ზემოთ აღწერილ ყველა ტიპს, სხვა სტრუქტურებს და “თავის თავს” (რეკურსიული სტრუქტურა)
ok structs require thinking, but I think they can be implemented, via adding a functionality of custom types in 
Data 
Ზემოთ აღწერილი ყველა ტიპის მასივები uhmm this can be done just by allocating that amount of memory in stack 
უნდა შეეძლოს:
არითმეტიკული და ლოგიკური ოპერაციების შესრულება This is actually what I will implement today 
ცვლადების აღწერა და მნიშვნელობის მინიჭება My compilator is already fully capable of doing this 
ფუნქციების აღწერა და მათი გამოძახება არამარტო სახელით არამედ მათი მიმთითებლითაც Ok, this will be added
if/else I need to add this 
for/while/do-while ციკლები and this too 

The plan now is to add operator support and to do that, we need theory, we need to add operators and must be 
able to calculate expressions. Expression calculations can be done using dual stack approach and separate 
module for this would be quite helpful. Where will operators appear? currently, they can only appear in 
assigning values to variables(changing value of variable like x++ is not permitted, x++ is actually 
x = x + 1, which is assignment of new variable one more from x). Where else would operators appear? 
What operators do we have: logical operators: <, >, ==, <=, >=, ||, &&, (, ). This will bring the idea of boolean, and
I will just simply consider it to be a int type. that is 0, if logical condition fails, else some non - zero 
integer. We also have arithmetical operators: +, -, *, /, =, (, ). and Also we have bit operations, but because there
is not a say for bit operations to be necessary, I will not add them, but it is not that hard to be honest. 

PLAN: add support for operators +, -, *, /, =, (, ). I will change the theme of vscode and just slowly start
doing. whole weekend is for this. If you approach everything with love, suddenly the darkness is not so dark
anymore. 

I will know add following functionality to instructions module. That will be addition, subtraction, multiplication
and division of two variables, or variable and constant, or constants. this ( and this ) along with 
operation precedence will allow us to determine what operations must be done, but what we sure know is that
any expressions can be boiled down to x op y, where x and y are both variables, one of them are variables, or 
both of them are constants. So it seems logical to add instructions for x op y, where x and y are either 
variables or constants.   

I added the functionality of instructions module. And I believe it will help me out a lot. Now, it is time to implement Mr_Assembler's new
method I will add, that is Mr_Assembler_calcExpr, that will fully cover right part of = not being a single constant value.

Generalization of these tasks require the chain of commands to be completed in correct order. In the near future, logical operators will 
be added too and they can be blended in with arithmetic operators too. So we need a way, to determine what operation and on what has to 
be done first and make this chain. For this, I believe separate module will be quite a good thing. Any number of chained operations boil 
down to some number of operations between two variables(or constants). examples: 

x = y + z - 2 * 5 || 7. In this case, I will write all such instructions: 

y + z -> t0 

2*5 -> t1 

y + z - 2*5 -> t0 (operation on t0 and t1)

then we have t0 || 7 which is 1 because t0 is not 0 

then we have assignment x = 1 

So = has lowest precedence. We need to implement these ideas and also add support for () as these force some operations to be completed
first. All of these are connected to posfix representation and this representation can be generalized onto larger commands.
We also need chain of command validation and so on. This may need separate module or not. I believe Mr_Assembler is fully capable of solving
expressions, but separate module still is good idea for storing precedence table, for instance, or having a function of finding operations 
to be done in order. This needs careful thought, but is possible. Actually, this is the most difficult task of all of building the compiler. 
As functions are simply lables with additional logic at the top and end, and if - else are just branches already existing in risc - v 
assembly. Most difficult problem is using precedence table to do operations between only two variables(registers) and obtaining final 
result. All of this is assembly instructions logic. Only thing we really need to calculate in Mr_Assembler are temporary values obtained
by calculations of highest priority and overall result to be stored in variable(if needed). There is a problem that we can run out of 
registers, but that will not be the case, as I will heavily rely on using stack to store calculation results of highest priority and put 
them to just two fixed registers, when doing a operation. I repeat, This is the most difficult part of this compiler, and I will do it 
tomorrow. I shall now consider examples of tokens while doing variable assignment and find a way to dissolve it into separate managable 
steps, order will not be the problem, but how I will store temporary results will be. I have implemented instruction support for taking 
out two variables from the stack, doing operation on them and putting the answer into a register. Now, I have to use series of these 
operations to calculate more complex expressions. and first step will be posfix representation. I will consider, for now, that input 
is validated, it has correct parenthesis, all is correct. And I will just apply posfix to see what I get: 

int y = 3 + x + 5 + z; 

posfix works using two stacks(one for operations, second for constants and variables)
I just came up with idea that literal stack could be used for storing temporary variables, literal stack, literal, there would be no better
way I believe to store temporary variables. But first, we need posfix written expression(it eradicates parenthesis and gives exact order
to evaluate things). I will evaluate whole expression and I have instruction for each operation. so I think generalization will not be the 
problem. So that means that int itself is also an operation. that is a variable declaration. Will not hurt to try. variable type declaration
operation has bigger priority than =, because variable has to exist first, before I can assign anything to it. 
  

stk2: = + + + + 

y int 3 x 5 z + + + = (this is the posfix representation of above expression)


we need two stacks to evaluate this and we also need to use sp manipulations(I will literally store temporary values in stack). 

Since this task is kind of difficult and no one really does x = y + 1 = 3 = 4 for instance, this is not beautiful. I will implement only 
the possibility of having single assignment =. So my expression calculator will only take care of what is right to the =. 

= (x + 3 * y - z) - 5 

how would I calculate this? 

first, posfix 


stk2 :   


I looked it up and found two - register interplay approach that works like a charm and I need to be able to handle it perfectly, before 
implementation and it will naturally connect to what I have right now. what I did was to load the right token to a register and store 
that register's value into my variable. what will now be different is that I will store the result of the expression in the variable, along 
with writing all the instructions that are required to fully resolve an expression. The only real thing that needs instructions to be written
is variable definition, assignment and reading variable and since at each step, I only need to operate only on two variables. I can simply
store values in two registers and accumulate it in one register and load variables in the other. So I have accumulator and loader registers. 
5 + 3 for instance does not really need separate instruction, as really it is just 8, this will allow us to make calculations little 
simpler. So in the case of expression calculations, only loading I will do is loading into a loader register, and using one more register
for other thing. The dual stack approach will be used, BUT will not be shown in the assembly itself. In assembly, I will just only load 
variables in registers and of course do operations between registers, but values stored on the stack will not be shown in the assembly 
itself. 

What I am stuck on is basically how much of the expression details has to be shown in assembly. 

I define few types of coverage: 

0% coverage - is one where I just calculate the expression with taking variable values(as I have them stored) and doing operations literally 
and then after final single answer is determined, I call assignVar on that constant. This is the most simplest we can get, the whole 
procedure of calculating expression translates to few instructions that is to just define a variable and assign a value to a variable. 
drawbacks is that variables are actually read from stack, so we need to reflect that in assembly too, they cannot appear from thin air. 

SOME coverage - This one actually shows instructions for pulling out variable values out of stack(this is just calling my instruction 
function for opVariables). This is actually good, but problem is that we cannot really show actual acummulation of answer in a register. 
What I am saying is that actual calculations(dual stack algorithm) will still be part of a compiler, it will not appear in assembly. 
In assembly, I will just have taking out variables and doing calculations in registers. but actual answer will not be stored in registers, 
I will just put it at last in single register from the answer I cooked out with algorithm and then call my Mr_Assembler to handle assigned
or unassigned variable on that value. This case will show actual details of really taking out variables from stack and doing operations. 
But it will not show integer stack. I just need validation that this is accurate. 



I will eventually rename Mr_Assembler to Mr_Compilator 
as Mr_Assembler name is not entirely accurate as assembler translates assembly instructions to machine code, compilator creates assembly 
instructions, not the assembler. 


x = 3 + 2 + 5 + 3 + 7 + 8 


(5 + 7 + 2 + x) - (3 + 2) + 4 * 5

+ *

5 7 + 2 + x + 3 2 + - 4 5 * +       
 

30



I decided to store intermediate results in actual stack at negative offsets, or move sp down for it and move it up again one the expression
is fully calculated. This is not most efficient, but we are not thriving for optimizations, we are thriving for correctness. I will now 
show how exactly will expression calculation code look: 


I have this posfix expression: 5 7 + 2 + x + 3 2 + - 4 5 * +       


I decided to create actual variables in stack to simulate int stack I will call them tmp. 

I need to add a support of removing variables from current_variables vector as adding a support of scopes requires us to fold up the stack
once we are done, but we need to also clean out vector out of all variables that were defined in that stack frame. I will implement new 
Mr_Assembler function. 

Now, before we go to adding label support that extends our compiler to support functions, scopes, if statements and loops. I have to take
care of two things: Calculating complex expressions and validating such expressions. 


After some detailed analysis I have come up with conclusion that I need a separate module for transforming, validating tokens, before 
passing them to Mr_Assembler. Who will best fit the role is the question, it is kind of a token filter thing whose only purpose is to 
take a token, validate it and handle it in a way that Mr_Compilator can handle it. Data module will not be eligible to do that. And it 
is the huge burden for Mr_Compilator already to do that. But to do that, we need to think about { and }. { creates a new scope and once 
} comes, it means scope ended and all the variables created in the stack after start of the scope must be removed and stack must be folded
up. So this has to be added first to fully do what I am about to do right now. I have added scope support. and it works as intended and now 
It is time to add token filterer that will be additional layer of filters before Mr_Compilator_analyze takes effect. it will temporarily 
take a hold of a token in compilator_ask function and will turn it into a scope with number of tokens. This will now be done easily, It 
will construct data vector and hold compilator before all tokens are completed. Now, I will fix one bug, that is when I write int y = x; 
for instance it immediately loads x's value in the register and assigns it to y, I want to show that x's value is taken from stack and 
written to y instead. and I think it is easily fixable. Then today's work ends. I fixed those bugs and now code works as intended. Now, we
need to add filter functionality. The purpose of filter is to take the given token and filter it. Filtering means number of things: 
First of all, it will turn any expression into a posfix representation. and Then it will generate scope - based tokens that will be passed
to Mr_Compilator instead of that single token. Filter functions will be called from Mr_Compilator in ask, before we pass them to analyze 
method. 

Now, let us think how it will dissolve expression, suppose we have following: 
y = 7 
a = 3 
int x = y + 3 * 2 / 5 + (7 - a); 

7 + 6 / 5 + 4 = 11 + 1 = 12 

Filterer will first turn this expression(after =) to a posfix representation based on the known algorithm I will implement. 

y 3 2 * 5 / + 7 a  - +    

Now, as we have this, I will transfer this into following instructions for Mr_Compilator: 

first instruction is 3*2 so I write int tmp_001 = 3 * 2;
I insert tmp_001 back to stack 
I have y tmp_001 5 / 
so I write int tmp_002 = tmp_001 / 5; 
I insert y tmp_002 is the stack and so on 
tmp_005 

int x; //declare a variable outside if it has int, otherwise, do not include this  
{;
int tmp_001 = 3 * 2; 
int tmp_002 = tmp_001 / 5; 
int tmp_003 = y + tmp_002; 
int tmp_004 = 7 - a; 
int tmp_005 = tmp_003 + tmp_004; 
x = tmp_005; 
}; 


I think it is better to call filter from CRC and then filer will take care of calling ask function of assembler. Now, All we have to do is 
to write and implement functionality of filter and test it in detail as it has very big responsibility. 

Today, I will only do stylistic improvements: that is int x=y+3; and int x = y + 3; and int x = y+ 3; all of 
them must be applicable to Mr_Assembler(filter module then Mr_Assembler). 

and one more, I will allow users to make comments(starting with /* and ending with */)


I will start with the first one. Since I dependent on strTok functionality of the C string library(it ignores
whitespaces), I can just modify a token a little bit before it is passed to a filter and just 
make each operator (=, *, +, -, / ...) to have a whitespace before and after it. this approach guarantees 
that 2*3 will be applicable for my application. I will add this into filter module as a private access 
function, because it is not something to be shared along modules(not important enough) 

Now, I will add comment functionality. What must happen? we must simply ignore all the code that is after 
/* and before */. I believe this is the role of CRC, as he is the reader of the file and hence he needs to 
remove all the unnecessary content from it. I will add new private access function that will look for ch 
combination /* and continue deleting data till */ combination is not reached. two - length sliding window 
is sufficient for this to work. It would be better if I do this in tokenize function. 

Now, we will implement conditional logic in our application. that is if, else, else if statements. but before
we do that, we need to add support for booleans. Standard C does not have separate keyword for boolean, and 
uses other types for checking the condition. Maybe it is for the best to not add boolean keyword as a valid 
variable type in our application. instead, I will share C's approach and just have an int(or short or long) to
represent simple statement. Before we continue, we need to define few things: just like expressions, there 
exists simple and complex statements. statements can be built via logical operators, that are ||(logical or), 
&&(logical and), !(logical negation), >(more than), <(less than), ==(equal to),>=(same as a == b || a > b), 
<=(same as a == b || a < b), They can be evaluated in the same way as expressions with arithmetic operators 
are evaluated. We just need to give them a priority(just add operators to priority generator and also tell
CRC how to evaluate && or || or >= or so on). But this will get ugly pretty quickly. As there are already loads
of ifs in the priority generator function. what if instead we refactor our code such that priorities of each 
operator are written in strVector and are written there in increasing order of priority. then we can do binary
search(will be implemented later) over a vector to find the current priority and then return its index. if 
two things have same priority, they will be added next to each other. Since some operators are multicharacter.
such refactoring makes sense: TODO : make CRC able to understand a || b or blend of arithmetic and logical 
operators a || b && c || e for instance. but this complicates things a little. refactoring is necessary, as 
operator separator function only works for single characters. but && and || are multi - character operators. 
 
As I have analyzed it. it is better to first add if and else. and also refactor the operator priority method 
that gives us priority of a given operator. before this, I will add if and else. I just need to have if 
keyword occupied(will add operation separation later). I will declare labels. And since lable is not 
reusable. I have to have kind of a vector that stores currently created labels inside the assembly generated
code. We are going into a label teritorry, here on, all the new additions require label support, so we have to 
know how to store used labels and what labels to create. Since Data module is so short, it will be useful to 
add operator priority support there via storing all operators and their priorities(with respect to other 
operators), we will be able to quickly know the operator we are currently handling and hence be able to 
efficiently separate it with blank spaces and generate assembly instructions. So first thing we do is to 
add label support, that stores currently occupied labels and integer i, that is used to create labels with 
names tmplb_i. All if statements and later while, for loops will use tmplb_i kind of labels. Functions itself 
will use their own names as labels. 

The kind of code this must compile is following: 

if ( 1 ) 
{;   


}; 

or 


if ( 0 ) 
{;


}; 

Any complex if statement will boil down to one of the above, if 0 is written in ( ), we just skip the whole 
code. 
otherwise, we run the code in the scope. 

if logic will always be coupled with else. implicit if will be turned to following: 

if ( 1 ) 
{;

one-scope 
    
};

else 

{;


}; 


So most general form is following: 


if ( 1 ) 
{;

if_scope 

};

else 

{; 

else_scope 

}; 

How exოactly will this be done? 


all of this code will be transformed to just creating scopes, that is: 

if ( 1 ) 
{;
int x = 3; 
int y = x + 1; 
}; 

will be transformed to: 

{; 
int x = 3; 
int y = x + 1; 
}; 


if ( 1 ) 
{;

if_scope 

};

else 

{; 

else_scope 

}; 

this will be transformed to following, just we will add branch statement and a single label: 

{;

if_scope 
}; 


{;

else_scope 
}; 



if ( 1 ) -> 

li t0, 1 
beq t0, zero, else 
(assembly instructions )

else : 


I will add few functions to Mr_Compilator. We will add create label function that creates new temporary
label if name is not specified, otherwise, creates label with the name given. I need a different approach 
here, I cannot inject code to Mr_Compilator in this case. how can I merge stray scopes {} with the things 
I want? 

Since any scope is connected to either if, while, or function definition(not call, this is important! only
definition). we can declare a new label every time new stack frame is created(in open scope only). 

each scope represents particular branch, hence label. function is a special label where in the scope we 
are loading or storing variables in from or in stack and storing ra if other function calls happen. all boil 
down to scopes. and we will name each scope a label. We need to also know where the scope ends.


I named each scope as a label now, and now I want to know when the scope ends. before that, I think I can 
already implement simple if statement and we will go from there: 

simple if statement is following 

some code is the 

if ( 1 ) {; 
 some_code 
}; 

rest_of_the_code 


what are assembly instructions? 

li t0, 1 
beq t0, zero, tmplb_(i + 1)  

tmplb_(i) : 
some code 

tmplb_(i + 1) : 


we just add these two lines(li t0, 1 
beq t0, zero, tmplb_(i)  )

if I write this, then any complex pattern of if - else statements can be transormed to nesting or combination 
of such simple ifs. 


for instance, 


take if --- else 

this is simple as 

if ( cond ) {



}

if ( !cond ) {

}

and any complex expression with additional operators will be implemented tomorrow and they will be boiled down
to 0 or not 0, essentially, nesting or combination of if statements. ok this is decided. but how do we know 
where to jump to beforehand in 
li t0, 1 
beq t0, zero, tmplb_(i + 1)  

just like each scope creates new tmp variable(normal {; };)

simple if statement creates a new scope and they can be nested to just like scopes. it can be considered to 
be type of scope too. I will create new strVector exclusively for storing the label each if's branch must 
jump to if condition is not satisfied. 

Before I continue, I have to do one of the hardest commits I have ever done since starting working on this 
project. That is I am not adding anything, I am refactoring my code, but it is ok, if it goes wrong, I will 
revert back to older commit. The refactoring that is necessary and that will help me out a lot in future is 
how priorities are retrieved, when we are working with complex expressions. I have to add support for 
&&, ||, !, ==, > and <. I already have a complete mechanism that allows one to do this. What I need is to 
simply add this operators as valid operators in the priority table. I could have just added those 4 operators
directly to the function that returns priorities, but function becomes quite large and I do not like it. also 
some of those operators are not single characters(&&, ||, ==). Then after this refactoring, all we have to do
is figure out how we will separate those variables. I have just came up with the particular idea, which does 
not let me avoid refactoring, but will allow me to separate variables efficiently. That is I will have my own 
table of operators, but difference is I will have single characters for each. 

I have successfully refactored get_priority method via adding functionality to Data module. Now, I am almost
ready to add logical operator support. Just one thing, I shall be able to separate out two - character long 
operators too. if operator is more than 2 character's long, than it should not exist. So instead of doing 
single traversal with single character, I will do sliding window approach of size 2 and that will fix this 
problem(We are supposing that operation cannot be longer than string of size 2). 

This has been done. Now it is time to implement functionality of each operator. 

Now, how to implement this functionality? 

I need two things: to tell good sir compilator how to evaluate x && y for instance and also to tell 
instructions how to create the instruction for x && y. 

First thing I will add is == operator. Well, filter has to transform each such instruction 
to combination of simple if statements. this will simply injected to Mr_Assembler. 
so instead of x && y; for instance. where we shall load a result to a register(as that is the point of 
the expression). I will tell Mr_Assembler to do different C instructons instead(just telling compilator 
thing it cannot understand as a thing it can understand). 

Will be written tomorrow. 